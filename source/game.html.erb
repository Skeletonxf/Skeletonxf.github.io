<%= partial :back %>
<h1 class = "center" id = "title">
  A game eventually
</h1>
<div id = "flex-wrapper">
  <div id = "armies">
    <div id = "armies-all">
      <h2>Available</h2>
      <ol id = "territory-armies-all"></ol>
    </div>
    <div id = "armies-selected">
      <h2>Selected</h2>
      <ol id = "territory-armies-selected"></ol>
    </div>
    <div id = "armies-attack"></div>
    <div id = "attacks">
      <h2>Orders</h2>
      <ol id = "territory-attacks"></ol>
    </div>
  </div>
  <div id = "map">
    <div id = "territories">
      <% mid = "$" %>
      <% inner = 1 %>
      <% middle = 1 %>
      <% outer = 1 %>
      <% base = 1 %>
      <% water = 1 %>
      <% 6.times do |n| %>
        <div id = "section<%= n*2 %>" class="section">
          <div class="container">
            <ol class="even nothing-up face-to-face-down">
              <li class='hex base' id='base<%= base %>'>
                <div class="content info">
                  <p class='id'><%= base %></p>
                  <% base += 1 %>
                </div>
                <div class="content units"></div>
              </li>
            </ol>
            <ol class="odd face-to-face-up point-to-point-down">
              <li class='hex' id='outer<%= outer %>'>
                <div class="content info">
                  <p class='id'><%= outer %></p>
                  <% outer += 1 %>
                </div>
                <div class="content units"></div>
              </li>
              <li class='hex' id='outer<%= outer %>'>
                <div class="content info">
                  <p class='id'><%= outer %></p>
                  <% outer += 1 %>
                </div>
                <div class="content units"></div>
              </li>
            </ol>
            <ol class="odd point-to-point-up face-to-face-down">
              <li class='hex' id='middle<%= middle %>'>
                <div class="content info">
                  <p class='id'><%= middle %></p>
                  <% middle += 1 %>
                </div>
                <div class="content units"></div>
              </li>
              <li class='hex' id='middle<%= middle %>'>
                <div class="content info">
                  <p class='id'><%= middle %></p>
                  <% middle += 1 %>
                </div>
                <div class="content units"></div>
              </li>
            </ol>
            <ol class="even face-to-face-up point-to-point-down">
              <li class='hex inner' id='inner<%= inner %>'>
                <div class="content info">
                  <p class='id'><%= inner %></p>
                  <% inner += 1 %>
                </div>
                <div class="content units"></div>
              </li>
            </ol>
            <ol class="even point-to-point-up nothing-down">
              <li class='hex blank'></li>
            </ol>
          </div>
        </div>
        <div id = "section<%= (n*2)+1 %>" class="section">
          <div class="container">
            <ol class="odd nothing-up point-to-point-down">
              <li class='hex water', id='water<%= water %>'>
                <div class="content info">
                  <p class='id'><%= water %></p>
                  <% water += 1 %>
                </div>
                <div class="content units"></div>
              </li>
            </ol>
            <ol class="odd point-to-point-up point-to-point-down">
              <li class='hex blank half'></li>
            </ol>
            <ol class="odd point-to-point-up point-to-point-down">
              <li class='hex' id='middle<%= middle %>'>
                <div class="content info">
                  <p class='id'><%= middle %></p>
                  <% middle += 1 %>
                </div>
                <div class="content units"></div>
              </li>
            </ol>
            <ol class="odd point-to-point-up point-to-point-down">
              <li class='hex inner' id='inner<%= inner %>'>
                <div class="content info">
                  <p class='id'><%= inner %></p>
                  <% inner += 1 %>
                </div>
                <div class="content units"></div>
              </li>
            </ol>
            <ol class="odd point-to-point-up nothing-down">
              <li class='hex blank half'></li>
            </ol>
          </div>
        </div>
      <% end %>
      <div id="section12" class="center section">
        <div class="container">
          <ol class="center odd nothing-up nothing-down">
            <li class="center hex" id='<%= mid %>'>
              <div class="content info">
                <p class='id mid'><%= mid %></p>
              </div>
              <div class="content units"></div>
            </li>
          </ol>
        </div>
      </div>
    </div>
    <svg id="paths"></svg>
    <svg id="walls"></svg>
    <svg id="mines"></svg>
    <svg id="castles"></svg>
  </div>
  <div id = "info">
    <h2 id = "territory-name"></h2>
    <h3>Control</h3>
    <p id = "territory-controller"></p>
    <h3>Structures</h3>
    <p id = "territory-mines"></p>
    <p id = "territory-wall"></p>
    <p id = "territory-castle"></p>
    <h3>Gold Income</h3>
    <p id = "territory-gold-income"></p>
    <div id="info-build-units">
      <h3>Buy Units</h3>
      <h4>20 Gold</h4>
      <div class="buy">
        <label for="archers">Archers</label>
        <input type="number" id="archers"></input>
      </div>
      <div class="buy">
        <label for="calvary">Calvary</label>
        <input type="number" id="calvary"></input>
      </div>
      <div class="buy">
        <label for="infantry">Infantry</label>
        <input type="number" id="infantry"></input>
      </div>
      <h4>1500 Gold</h4>
      <div class="buy">
        <label for="rams">Battering Ram</label>
        <input type="number" id="rams"></input>
      </div>
    </div>
    <div id="info-buttons">
      <h4>Territory Upgrades</h4>
      <button>Build Mine (200)</button>
      <button>Build Wall (1500)</button>
      <button>Build Castle (2000)</button>
      <button>Raze Down</button>
    </div>
  </div>
  <div id = "players">
    <ul>
      <li id = "p1-player-info">
        <h2>Player 1</h2>
        <h3>Resources</h3>
        <p id = "p1-gold">Gold: 500</p>
        <p id = "p1-archers-level">Archers Level 2</p>
        <p id = "p1-calvary-level">Calvary Level 1</p>
        <p id = "p1-infantry-level">Infantry Level 3</p>
        <div id = "turn-player-unit-upgrades">
          <button id = "turn-player-upgrade-archers">Upgrade Archers</button>
          <button id = "turn-player-upgrade-calvary">Upgrade Calvary</button>
          <button id = "turn-player-upgrade-infantry">Upgrade Infantry</button>
        </div>
        <button id="end-turn">End Turn</button>
      </li>
      <li id = "p2-player-info">
        <h2>Player 2</h2>
        <h3>Resources</h3>
        <p id = "p2-gold">Gold: 500</p>
        <p id = "p2-archers-level">Archers Level 2</p>
        <p id = "p2-calvary-level">Calvary Level 1</p>
        <p id = "p2-infantry-level">Infantry Level 3</p>
      </li>
      <li id = "p3-player-info">
        <h2>Player 3</h2>
        <h3>Resources</h3>
        <p id = "p3-gold">Gold: 500</p>
        <p id = "p3-archers-level">Archers Level 2</p>
        <p id = "p3-calvary-level">Calvary Level 1</p>
        <p id = "p3-infantry-level">Infantry Level 3</p>
      </li>
      <li id = "p4-player-info">
        <h2>Player 4</h2>
        <h3>Resources</h3>
        <p id = "p4-gold">Gold: 500</p>
        <p id = "p4-archers-level">Archers Level 2</p>
        <p id = "p4-calvary-level">Calvary Level 1</p>
        <p id = "p4-infantry-level">Infantry Level 3</p>
      </li>
      <li id = "p5-player-info">
        <h2>Player 5</h2>
        <h3>Resources</h3>
        <p id = "p5-gold">Gold: 500</p>
        <p id = "p5-archers-level">Archers Level 2</p>
        <p id = "p5-calvary-level">Calvary Level 1</p>
        <p id = "p5-infantry-level">Infantry Level 3</p>
      </li>
      <li id = "p6-player-info">
        <h2>Player 6</h2>
        <h3>Resources</h3>
        <p id = "p6-gold">Gold: 500</p>
        <p id = "p6-archers-level">Archers Level 2</p>
        <p id = "p6-calvary-level">Calvary Level 1</p>
        <p id = "p6-infantry-level">Infantry Level 3</p>
      </li>
    </ul>
  </div>
</div>

<script>
let game = document.getElementById('map')

let drawLine = null;
let drawWall = null;
let drawMine = null;
{
  let paths = document.getElementById('paths')
  let walls = document.getElementById('walls')
  let mines = document.getElementById('mines')
  let castles = document.getElementById('castles')

  let svgNS = "http://www.w3.org/2000/svg"
  let createLine = function(values) {
    let line = document.createElementNS(svgNS, 'line')
    line.setAttributeNS(null, 'stroke-width', 12)
    for (let property in values) {
      line.setAttributeNS(null, property, values[property]);
    }
    paths.appendChild(line)
  }
  let createCircle = function(values, parent) {
    let circle = document.createElementNS(svgNS, 'circle')
    for (let property in values) {
      circle.setAttributeNS(null, property, values[property]);
    }
    parent.appendChild(circle)
  }


  function bounds(element) {
    return element.getBoundingClientRect()
  }

  drawLine = function(element1, element2) {
    let color = 'darkgreen'
    if (element1.id.includes('water') || element2.id.includes('water')) {
      color = 'skyblue'
    }
    createLine({
      x1: (bounds(element1).x + (bounds(element1).width/2)) - bounds(paths).x,
      y1: (bounds(element1).y + (bounds(element1).height/2)) - bounds(paths).y,
      x2: (bounds(element2).x + (bounds(element2).width/2)) - bounds(paths).x,
      y2: (bounds(element2).y + (bounds(element2).height/2)) - bounds(paths).y,
      stroke: color
    })
  }

  drawWall = function(element) {
    let radius = 35
    if (element.id === '$') {
      radius = 80
    }
    createCircle({
      cx: (bounds(element).x + (bounds(element).width/2)) - bounds(paths).x,
      cy: (bounds(element).y + (bounds(element).height/2)) - bounds(paths).y,
      fill: 'grey',
      r: radius
    }, walls)
  }

  drawMine = function(element, level) {
    let cx = (bounds(element).x + (bounds(element).width/2)) - bounds(paths).x
    let cy = (bounds(element).y + (bounds(element).height/2)) - bounds(paths).y
    let radius = 28
    let increment = -Math.PI/6
    if (element.id === '$') {
      radius = 70
      increment = -Math.PI/12
    }
    // draw mines around the perimeter
    for (let i = 0; i < level; i++) {
      let angle = 2.3*(Math.PI/3) + (i*increment)
      createCircle({
        cx: cx + (Math.sin(angle)*radius),
        cy: cy + (Math.cos(angle)*radius),
        fill: 'gold',
        r: 5
      }, mines)
    }
  }

  drawCastle = function(element) {
    let cx = (bounds(element).x + (bounds(element).width/2)) - bounds(paths).x
    let cy = (bounds(element).y + (bounds(element).height/2)) - bounds(paths).y
    let radius = 24
    if (element.id === '$') {
      radius = 50
    }
    let angle = -Math.PI/3
    createCircle({
      cx: cx + (Math.sin(angle)*radius),
      cy: cy + (Math.cos(angle)*radius),
      fill: 'black',
      r: element.id === '$' ? 12 : 6
    }, castles)
  }
}

let graph = {
  '$': ['inner2', 'inner4', 'inner6', 'inner8', 'inner10', 'inner12'],
  inner1: ['inner2', 'inner12', 'middle1', 'middle2'],
  inner2: ['$', 'inner1', 'inner3', 'middle3'],
  inner3: ['inner2', 'inner4', 'middle4', 'middle5'],
  inner4: ['$', 'inner3', 'inner5', 'middle6'],
  inner5: ['inner4', 'inner6', 'middle7', 'middle8'],
  inner6: ['$', 'inner5', 'inner7', 'middle9'],
  inner7: ['inner6', 'inner8', 'middle10', 'middle11'],
  inner8: ['$', 'inner7', 'inner9', 'middle12'],
  inner9: ['inner8', 'inner10', 'middle13', 'middle14'],
  inner10: ['$', 'inner9', 'inner11', 'middle15'],
  inner11: ['inner10', 'inner12', 'middle16', 'middle17'],
  inner12: ['$', 'inner1', 'inner11', 'middle18'],
  middle1: ['inner1', 'middle18', 'middle2', 'outer1', 'outer2', 'water6'],
  middle2: ['inner1', 'middle1', 'middle3', 'outer1', 'outer2', 'water1'],
  middle3: ['inner2', 'middle2', 'middle4', 'water1'],
  middle4: ['inner3', 'middle3', 'middle5', 'outer3', 'outer4', 'water1'],
  middle5: ['inner3', 'middle4', 'middle6', 'outer3', 'outer4', 'water2'],
  middle6: ['inner4', 'middle5', 'middle7', 'water2'],
  middle7: ['inner5', 'middle6', 'middle8', 'outer5', 'outer6', 'water2'],
  middle8: ['inner5', 'middle7', 'middle9', 'outer5', 'outer6', 'water3'],
  middle9: ['inner6', 'middle8', 'middle10', 'water3'],
  middle10: ['inner7', 'middle9', 'middle11', 'outer7', 'outer8', 'water3'],
  middle11: ['inner7', 'middle10', 'middle12', 'outer7', 'outer8', 'water4'],
  middle12: ['inner8', 'middle11', 'middle13', 'water4'],
  middle13: ['inner9', 'middle12', 'middle14', 'outer9', 'outer10', 'water4'],
  middle14: ['inner9', 'middle13', 'middle15', 'outer9', 'outer10', 'water5'],
  middle15: ['inner10', 'middle14', 'middle16', 'water5'],
  middle16: ['inner11', 'middle15', 'middle17', 'outer11', 'outer12', 'water5'],
  middle17: ['inner11', 'middle16', 'middle18', 'outer11', 'outer12', 'water6'],
  middle18: ['inner12', 'middle17', 'middle1', 'water6'],
  outer1: ['middle1', 'middle2', 'base1', 'water6'],
  outer2: ['middle1', 'middle2', 'base1', 'water1'],
  outer3: ['middle4', 'middle5', 'base2', 'water1'],
  outer4: ['middle4', 'middle5', 'base2', 'water2'],
  outer5: ['middle7', 'middle8', 'base3', 'water2'],
  outer6: ['middle7', 'middle8', 'base3', 'water3'],
  outer7: ['middle10', 'middle11', 'base4', 'water3'],
  outer8: ['middle10', 'middle11', 'base4', 'water4'],
  outer9: ['middle13', 'middle14', 'base5', 'water4'],
  outer10: ['middle13', 'middle14', 'base5', 'water5'],
  outer11: ['middle16', 'middle17', 'base6', 'water5'],
  outer12: ['middle16', 'middle17', 'base6', 'water6'],
  base1: ['outer1', 'outer2', 'water1', 'water6'],
  base2: ['outer3', 'outer4', 'water1', 'water2'],
  base3: ['outer5', 'outer6', 'water2', 'water3'],
  base4: ['outer7', 'outer8', 'water3', 'water4'],
  base5: ['outer9', 'outer10', 'water4', 'water5'],
  base6: ['outer11', 'outer12', 'water5', 'water6'],
  water1: ['base1', 'outer2', 'middle2', 'middle3', 'middle4', 'outer3', 'base2'],
  water2: ['base2', 'outer4', 'middle5', 'middle6', 'middle7', 'outer5', 'base3'],
  water3: ['base3', 'outer6', 'middle8', 'middle9', 'middle10', 'outer7', 'base4'],
  water4: ['base4', 'outer8', 'middle11', 'middle12', 'middle13', 'outer9', 'base5'],
  water5: ['base5', 'outer10', 'middle14', 'middle15', 'middle16', 'outer11', 'base6'],
  water6: ['base6', 'outer12', 'middle17', 'middle18', 'middle1', 'outer1', 'base1']
}

for (let node in graph) {
  graph[node].forEach((n) => {
    // TODO avoid drawing every line twice
    drawLine(document.getElementById(node), document.getElementById(n))
  })
}

let map = {}
{
  let player = 1
  for (let node in graph) {
    let element = document.getElementById(node)
    if (node.includes('base')) {
      map[node] = {
        armies: [{
          quantity: 30,
          type: 'Neutral',
          level: 1,
          id: 0
        }],
        player: 'p' + player,
        mines: 0,
        wall: true,
        castle: true,
        deployed: [],
        capital: true,
        justTaken: true,
        arriving: []
      }
      player += 1
    } else {
      map[node] = {
        armies: [{
          quantity: 10,
          type: 'Neutral',
          level: 1,
          id: 0
        }],
        player: 'neutral',
        mines: 0,
        wall: false,
        castle: false,
        deployed: [],
        capital: false,
        justTaken: false,
        arriving: []
      }
      if (node.includes('water')) {
        map[node].armies[0].quantity = 1000
      }
      if (node.includes('$')) {
        map[node].armies[0].quantity = 50
      }
    }
  }
}

let fullPlayerNames = {
  neutral: 'Neutral',
  p1: 'Player 1',
  p2: 'Player 2',
  p3: 'Player 3',
  p4: 'Player 4',
  p5: 'Player 5',
  p6: 'Player 6'
}

let uiState = 'selectFocus'
let attackFrom = null

for (let node in graph) {
  let element = document.getElementById(node)
  element.addEventListener('click', (event) => {
    if (uiState === 'selectFocus') {
      switchFocusTo(element)
    }
    if (uiState === 'attack') {
      attackTarget(element, attackFrom)
    }
  })
}

function getFullName(id) {
  let fullName = ""
  if (id === "$") {
    fullName = "Mid"
  } else {
    fullName = id.charAt(0).toUpperCase() + id.slice(1)
    let numbers = [
      fullName.indexOf('0'),
      fullName.indexOf('1'),
      fullName.indexOf('2'),
      fullName.indexOf('3'),
      fullName.indexOf('4'),
      fullName.indexOf('5'),
      fullName.indexOf('6'),
      fullName.indexOf('7'),
      fullName.indexOf('8'),
      fullName.indexOf('9')
    ]
    let number = -1
    // take max of non -1 numbers
    numbers.forEach((n) => {
      if ((n !== -1) && ((n < number) || number === -1)) {
        number = n
      }
    })
    if (number !== -1) {
      fullName = fullName.slice(0, number) + " " + fullName.slice(number)
    }
  }
  return fullName
}

var switchFocusTo = null
{
  function updateInfo(node) {
    let fullName = getFullName(node.id)

    document.getElementById('territory-name').textContent = fullName + " Info"
    document.getElementById('territory-controller').textContent = fullPlayerNames[map[node.id].player]
    document.getElementById('territory-mines').textContent = map[node.id].mines + " Mines"
    if (map[node.id].wall) {
      document.getElementById('territory-wall').textContent = "Wall"
    } else {
      document.getElementById('territory-wall').textContent = "No Wall"
    }
    if (map[node.id].castle) {
      document.getElementById('territory-castle').textContent = "Castle"
    } else {
      document.getElementById('territory-castle').textContent = "No Castle"
    }
    document.getElementById('territory-gold-income').textContent = territoryGoldIncome(node.id)
  }

  function updateArmies(node) {
    let armiesList = document.getElementById('territory-armies-all')
    // clear armies list
    while (armiesList.firstChild) {
      armiesList.removeChild(armiesList.firstChild)
    }

    let selectedList = document.getElementById('territory-armies-selected')
    // clear selected armies list
    while (selectedList.firstChild) {
      selectedList.removeChild(selectedList.firstChild)
    }

    // create button for attack/transfer
    let attackContainer = document.getElementById('armies-attack')
    // delete all old attack buttons
    while (attackContainer.firstChild) {
      attackContainer.removeChild(attackContainer.firstChild)
    }
    let button = document.createElement('button')
    button.textContent = 'Attack/Transfer'
    attackContainer.appendChild(button)

    if (map[node.id].player === turnPlayer) {
      document.getElementById('armies-selected').classList.remove('hidden')
    } else {
      document.getElementById('armies-selected').classList.add('hidden')
    }

    let attacksList = document.getElementById('territory-attacks')
    // clear deployed list
    while (attacksList.firstChild) {
      attacksList.removeChild(attacksList.firstChild)
    }

    function updateButton() {
      if (map[node.id].deployed.length === 0 ||
        map[node.id].deployed.every(d => d.target !== null) ||
        map[node.id].player !== turnPlayer) {
          button.setAttribute('disabled', 'disabled')
        } else {
          button.removeAttribute('disabled')
        }
    }
    updateButton()

    // setup army deployment UI for this territory
    map[node.id].armies.forEach(listArmy)

    function listArmy(army) {
      let li = document.createElement('li')
      let checkbox = document.createElement('input')
      checkbox.setAttribute('type', 'checkbox')
      let id = army.type + 'ArmyInTerritory' + army.id
      checkbox.setAttribute('id', id)
      let label = document.createElement('label')
      label.setAttribute('for', id)

      let quantity = document.createElement('input')
      quantity.setAttribute('type', 'number')
      quantity.value = army.quantity

      if (map[node.id].player === turnPlayer) {
        quantity.addEventListener('change', () => {
          // only allow splitting
          if (+quantity.value > army.quantity) {
            quantity.value = army.quantity
            return
          }
          if (+quantity.value < 1) {
            quantity.value = 1
            return
          }
          // split army
          let left = +quantity.value
          let right = +army.quantity - quantity.value

          // find all armies of this type in this territory
          let splitArmies = map[node.id].armies.filter(a => a.type === army.type)
          // find the highest id
          let highestID = splitArmies.reduce((accumulator, current) => {
            return Math.max(accumulator, current.id)
          }, 0)
          army.quantity = left
          let splitArmy = {
            quantity: right,
            type: army.type,
            level: army.level,
            id: highestID + 1
          }
          map[node.id].armies.push(splitArmy)
          listArmy(splitArmy)
        })
      } else {
        quantity.setAttribute('disabled', 'disabled')
      }

      let target = map[node.id].deployed.find((d) => {
        return d.army === army && d.target !== null
      })
      let hasTarget = target !== undefined

      let text = null
      // don't let the player see other player's deloyments
      if (hasTarget && map[node.id].player === turnPlayer) {
        text = document.createTextNode(army.type + ' ' + army.level + ' to ' +
          getFullName(target.target))
      } else {
        text = document.createTextNode(army.type + ' ' + army.level)
      }

      armiesList.appendChild(li)
      li.appendChild(checkbox)
      li.appendChild(label)
      label.appendChild(quantity)
      label.appendChild(text)

      // don't let the player see other player's deloyments
      if (map[node.id].player === turnPlayer) {
        // put all deployed armies back on the selected section
        if (map[node.id].deployed.some((d) => d.army === army)) {
          selectedList.append(li)
          checkbox.checked = true
          if (hasTarget) {
            // put this attack in the deployed section
            attacksList.append(li)
          }
        }
      }

      // don't let the player deploy non player armies
      if (map[node.id].player === turnPlayer) {
        // track deployed armies and don't trust the DOM for the values
        checkbox.addEventListener('change', () => {
          if ((checkbox.checked) && (!hasTarget)) {
            selectedList.append(li)
            map[node.id].deployed.push({
              army: army,
              target: null
            })
          } else {
            armiesList.append(li)
            map[node.id].deployed = map[node.id].deployed.filter(d => d.army !== army)
            hasTarget = false
          }

          // remove target location on now undeployed army
          label.removeChild(text)
          text = document.createTextNode(army.type + ' ' + army.level)
          label.appendChild(text)

          updateButton()

          console.log(map[node.id].deployed)
        })

        button.addEventListener('click', () => {
          let neighbours = graph[node.id]
          let nodes = neighbours.map(id => document.getElementById(id))
          // highlight all possible locations to attack/transfer
          nodes.forEach((n) => {
            n.classList.add('highlight')
          })
          uiState = 'attack'
          // mutate the global variable to let the recieving
          // event know the originating node
          attackFrom = node
        })
      }
    }
  }

  switchFocusTo = function(node) {
    updateInfo(node)
    updateArmies(node)
  }
}

function attackTarget(to, from) {
  if (from) {
    if (graph[from.id].includes(to.id)) {
      // mark all semi deployed armies with the target
      map[from.id].deployed.forEach((d) => {
        if (d.target === null) {
          d.target = to.id
        }
      })
    }
  }
  uiState = 'selectFocus'
  stopHighlighting()
  // find all armies for this target
  let targetArmies = map[from.id].deployed.filter((d) => {
    return d.target === to.id
  })
  let types = []
  let typeRepeats = []
  // find any repeated types going to the same target
  targetArmies.forEach((d) => {
    if (types.includes(d.army.type)) {
      if (!typeRepeats.includes(d.army.type)) {
        typeRepeats.push(d.army.type)
      }
    } else {
      types.push(d.army.type)
    }
  })
  typeRepeats.forEach((type) => {
    // for each repeated type to a target identify all armies of that type
    let repeatedTypesForTarget = targetArmies.filter((d) => {
      return d.army.type === type
    })
    let first = repeatedTypesForTarget[0]
    // merge these together
    if (first) {
      let totalQuantity = repeatedTypesForTarget.reduce(
        (accumulator, current) => {
          return accumulator + current.army.quantity
      }, 0)
      console.log('before change', map[from.id].armies)
      // raise quantity on remaining one
      first.army.quantity = totalQuantity
    }
    // remove the others
    let removals = []
    map[from.id].deployed = map[from.id].deployed.filter((d) => {
      let keep = d.army.type !== first.army.type || d.target !== first.target || d.army === first.army
      if (!keep) {
        removals.push(d.army)
      }
      return keep
    })
    map[from.id].armies = map[from.id].armies.filter((army) => {
      return !removals.includes(army)
    })
  })
  console.log('done', map[from.id].armies)
  // stay focused on the current node as the player
  // may want to deploy additional units
  // let this refresh the UI to show the new attacks
  switchFocusTo(from)
}

function stopHighlighting() {
  for (let node in map) {
    let element = document.getElementById(node)
    // reset highlighting on changing node focus
    element.classList.remove('highlight')
  }
}

let players = {};
['p1', 'p2', 'p3', 'p4', 'p5', 'p6'].forEach((p) => {
  players[p] = {
    upgrades: {
      archers: 1,
      calvary: 1,
      infantry: 1
    },
    gold: 0,
    goldIncome: 0,
    goldPublic: 0
  }
})

// mine income rates and upgrade costs
// index by level of mine 0-6
let mineIncome = [ 0, 100, 150, 190, 230, 250, 500 ]
// index by level of mine to buy 1-6
let mineUpgradeCost = [ 200, 300, 450, 600, 750, 1200 ]

function territoryGoldIncome(node) {
  // passive income for territory
  let income = 150
  if (node.includes('water')) {
    income = 0
  }
  if (map[node].capital) {
    income = 400
  }
  if (node.includes('$')) {
    if (map[node].justTaken) {
      income = 2000
    } else {
      income = 600
    }
  }
  // gain extra gold for mine levels
  return income += mineIncome[map[node].mines]
}

function applyPlayerGoldIncome() {
  for (let player in players) {
    players[player].goldIncome = 0
  }
  for (let node in map) {
    if (map[node].player !== 'neutral') {
      players[map[node].player].gold += territoryGoldIncome(node)
      players[map[node].player].goldIncome += territoryGoldIncome(node)
    }
  }
  for (let player in players) {
    players[player].goldPublic = players[player].gold
  }
  updatePlayerGold()
}

function getShortTerritoryUnits(army) {
  if (army.type === 'Neutral') {
    return army.quantity
  } else {
    return army.quantity + ' ' + army.type.charAt(0).toUpperCase()
  }
}

function updateMap() {
  let walls = document.getElementById('walls')
  // remove all walls
  while (walls.firstChild) {
    walls.removeChild(walls.firstChild)
  }

  let mines = document.getElementById('mines')
  // remove all mines
  while (mines.firstChild) {
    mines.removeChild(mines.firstChild)
  }

  let castles = document.getElementById('castles')
  // remove all castles
  while (castles.firstChild) {
    castles.removeChild(castles.firstChild)
  }

  for (let node in map) {
    let element = document.getElementById(node);
    // update colors for each node
    ['p1', 'p2', 'p3', 'p4', 'p5', 'p6'].forEach((p) => {
      element.classList.remove(p)
      if (map[node].player === p) {
        element.classList.add(p)
      }
    })
    // update unit counts
    let units = Array.from(element.childNodes).find(
      n => n.classList && n.classList.contains('units'))

    while (units.firstChild) {
      units.removeChild(units.firstChild)
    }

    map[node].armies.forEach((army) => {
      let p = document.createElement('p')
      p.textContent = getShortTerritoryUnits(army)
      units.appendChild(p)
    })

    if (map[node].wall) {
      drawWall(element)
    }

    if (map[node].mines > 0) {
      drawMine(element, map[node].mines)
    }

    if (map[node].castle) {
      drawCastle(element)
    }
  }
}

updateMap()
applyPlayerGoldIncome()

/* Turns */

let turn = 1
let phase = 1
var turnPlayer = 'p0' // needs hoisting

function changeTurnPlayer() {
  let player = +turnPlayer.slice(1)
  player += 1
  if (player > 6) {
    player = 1
    applyTurns()
  }
  turnPlayer = 'p' + player
  switchFocusTo(document.getElementById('base' + player))

  let title = document.getElementById('title')
  title.textContent = 'Player ' + player + "'s Turn - Phase: " + phase
  let playerInfo = document.getElementById('p' + player + '-player-info')
  let endTurnButton = document.getElementById('end-turn')
  // move end turn button to the next player
  playerInfo.append(endTurnButton)
}

document.getElementById('end-turn').addEventListener('click', changeTurnPlayer)

changeTurnPlayer()

// Updates UI showing player's gold.
// The gold of the player at the start of their turn is shown
// as each non turn player's gold.
function updatePlayerGold() {
  let elements = {
    p1: document.getElementById('p1-gold'),
    p2: document.getElementById('p2-gold'),
    p3: document.getElementById('p3-gold'),
    p4: document.getElementById('p4-gold'),
    p5: document.getElementById('p5-gold'),
    p6: document.getElementById('p6-gold')
  }
  for (let id in elements) {
    let element = elements[id]
    let player = players[id]
    if (turnPlayer === id) {
      element.textContent = 'Gold: ' + player.gold +
      ' Income: ' + player.goldIncome
    } else {
      element.textContent = 'Gold: ' + player.goldPublic +
      ' Income: ' + player.goldIncome
    }
  }
}

function applyTurns() {
  phase = phase += 1
  // The update function

  for (let node in map) {
    if (map[node].deployed.length > 0) {
      console.log(map[node].deployed)
      map[node].deployed.forEach((d) => {
        map[d.target].arriving.push({
          player: map[node].player,
          army: d.army,
          from: node
        })
      })
    }
  }

  // first opposing armies battle on edges
  for (let node in map) {
    if (map[node].arriving.length > 0) {
      if (map[node].deployed.length > 0) {
        map[node].deployed.forEach((d) => {
          map[node].arriving.forEach((a) => {
            // exclude units passing through the same player's territory
            // as they do not fight
            if ((d.target === a.from) && (map[node].player !== a.player)) {
              // armies meet on edge
              d.edgeBattle = true
              a.edgeBattle = true
            }
          })
        })
      }
    }
  }
  for (let node in map) {
    // find nodes with at least one edge battle
    if (map[node].arriving.some(a => a.edgeBattle)) {
      // the armies arriving to this node may be from multiple players or nodes
      let arriving = map[node].arriving.filter(a => a.edgeBattle)
      // collect list of each direction an edge battle is in
      let edgeBattles = []
      arriving.forEach((a) => {
        if (!edgeBattles.includes(a.from)) {
          edgeBattles.push(a.from)
        }
      })
      // process each direction in turn
      // the armies fighting on each edge do not need to interact
      // at this point
      edgeBattles.forEach((n) => {
        // collect the armies sent from this node onto the edge
        // in this direction for the battle
        let originating = map[node].deployed.filter(d => (d.target === n && d.edgeBattle))
        // in each direction there can only be 1 player attacking
        // so all incoming armies from this direction is the single opponent
        let incoming = arriving.filter(a => a.from === n)
        edgeBattle(originating, incoming)
      })
      // surviving armies need to then attack/defend on the node
    }
  }

  // remove deployed units from the territory they have left
  // these armies are still arriving at the new territory
  for (let node in map) {
    map[node].armies = map[node].armies.filter((a) => {
      return !map[node].deployed.map(d => d.army).includes(a)
    })
    map[node].deployed = []
  }

  // Battle for each territory with incoming arriving units.
  // Arriving units move into territory if successful.
  for (let node in map) {
    map[node].justTaken = false
    // do normal attack/defender battles (which may involve multiple players)
    if (map[node].arriving.length > 0) {
      console.log('units arriving to ', node, map[node].arriving, map[node].armies)
      let arrivingDefendingUnits = map[node].arriving.filter((a) => {
        // if a player sends units to one of their own territories
        // they join the defenders before battle for simplicity
        return a.player === map[node].player
      })
      console.log('arriving defending units', arrivingDefendingUnits)
      // take arriving defending units out of the arriving list
      map[node].arriving = map[node].arriving.filter((a) => {
        return !arrivingDefendingUnits.includes(a)
      })
      console.log('arriving after filter', map[node].arriving)
      // they join the end of the defending list of armies at this territory
      arrivingDefendingUnits.forEach((a) => {
        map[node].armies.push(a.army)
      })
      // perform battle for control of the node
      console.log('before battle', map[node].arriving, map[node].armies)
      nOnOneBattle(map[node].arriving, map[node].armies)
      if (map[node].armies.some(army => army.quantity > 0)) {
        // defenders hold territory, no update needed
      } else if (map[node].arriving.some(a => a.army.quantity > 0)) {
        // attackers win and take territory
        map[node].player = map[node].arriving.find(a => a.army.quantity > 0).player
        // surviving armies remain in territory
        map[node].armies = map[node].arriving.filter(a => a.army.quantity > 0).map(a => a.army)
        map[node].justTaken = true
      } else {
        // territory turns neutral
        map[node].armies = []
        // if only one player attacked this neutral territory
        // then they gain control of it anyway
        if ((map[node].player === 'neutral') &&
        (new Set(map[node].arriving.map(a => a.player))).size === 1) {
          map[node].player = map[node].arriving[0].player
        } else {
          map[node].player = 'neutral'
        }
      }
    }
  }

  // Clear unsuccessful arriving armies.
  for (let node in map) {
    map[node].arriving = []
  }

  // TODO apply territory purchases/upgrades

  applyPlayerGoldIncome()
  updateMap()
}

// Kills the armies battling along the edge till one side loses.
// Afterward the victor may have to fight defenders at the node.
function edgeBattle(originating, incoming) {
  // no defending bonus for either
  freeForAll([originating, incoming])
}

// The most simple attacker versus defender battle.
// Attacking army list and Defending army list.
function oneOnOneBattle(attackingArmies, defendingArmies) {
  let attackingArmy = 0
  let defendingArmy = 0
  while ((attackingArmy < attackingArmies.length) &&
    (defendingArmy < defendingArmies.length)) {
    // at least one army left on both sides
    let attackers = attackingArmies[attackingArmy]
    let defenders = defendingArmies[defendingArmy]
    // if an army is at 0 then pass
    if (attackers.quantity === 0) {
      attackingArmy += 1
      continue
    }
    if (defenders.quantity === 0) {
      defendingArmy += 1
      continue
    }
    let attackingArmyTradeForOne = battleMultiplier(attackers, defenders)
    let defendingArmyTradeForOne = battleMultiplier(defenders, attackers)
    console.log('trades', attackingArmyTradeForOne, defendingArmyTradeForOne)
    if (attackingArmyTradeForOne > defendingArmyTradeForOne) {
      // attacker should die anyway if able to
      // kill more than remaining defenders
      while (attackers.quantity > 0 && defenders.quantity > 0) {
        attackers.quantity -= 1
        defenders.quantity -= attackingArmyTradeForOne
      }
      if (defenders.quantity < 0) {
        defenders.quantity = 0
      }
    } else if (defendingArmyTradeForOne > attackingArmyTradeForOne) {
      // defender should survive if able
      // to kill more than remaining attackers
      while (defenders.quantity > 0 && attackers.quantity > 0) {
        defenders.quantity -= 1
        attackers.quantity -= defendingArmyTradeForOne
      }
      if (attackers.quantity < 0) {
        attackers.quantity = 0
        defenders.quantity += 1 // defender survives rounding
      }
    } else {
      if (attackers.quantity > defenders.quantity) {
        // all defenders die
        attackers.quantity -= defenders.quantity
        defenders.quantity = 0
      } else if (defenders.quantity > attackers.quantity) {
        // all attackers die
        defenders.quantity -= attackers.quantity
        attackers.quantity = 0
      } else {
        // both die
        defenders.quantity = 0
        attackers.quantity = 0
      }
    }
  }
}

// n on n cannot happen as it is impossible for multiple
// players to control the same territory.
// What is possible is n on 1 where the defender
// loses while multiple attackers are still fighting for
// the territory.
// Attacking list of arriving armies and Defending list of armies.
function nOnOneBattle(attacking, defending) {
  let attackingPlayers = attacking.reduce((players, arriving) => {
    if (!players.includes(arriving.player) && arriving.army.quantity > 0) {
      players.push(arriving.player)
    }
    return players
  }, [])
  if (attackingPlayers.length === 1) {
    // battle simplifies to 1 on 1
    return oneOnOneBattle(attacking.map(arriving => arriving.army), defending)
  }

  // like freeForAll but apply defender rounding advantage at each step
}

// List of list of armies fighting in free for all
// with no one with defending advantage.
function freeForAll(attackingList) {
  // calculate every tradeForOne
  // sum up 'kills' from every viewpoint fighting every other (round robin)
  // divide by highest value to normalise to 0-1 units dying
  // subtract and loop until at least all but one hit 0 life
}

// first against second index
let typeAdvantage = {
  Neutral: {
    Neutral: 0,
    Archers: 0,
    Calvary: 0,
    Infantry: 0
  },
  Archers: {
    Neutral: 0,
    Archers: 0,
    Calvary: -1, // weak to calvary
    Infantry: 1 // strong against infantry
  },
  Calvary: {
    Neutral: 0,
    Archers: 1, // strong against archers
    Calvary: 0,
    Infantry: -1 // weak to infantry
  },
  Infantry: {
    Neutral: 0,
    Archers: -1, // weak to archers
    Calvary: 1, // strong against calvary
    Infantry: 0
  }
}
function battleMultiplier(trade, against) {
  let levelDifference = trade.level - against.level
  return Math.pow(2,
    levelDifference + typeAdvantage[trade.type][against.type])
}

function battleTests() {
  console.log('A4 against I2 multiplier (8)', battleMultiplier({
    type: 'Archers',
    level: 4
  }, {
    type: 'Infantry',
    level: 2
  }))
  console.log('10 A4 against 15 I2 battle')
  let attackers = {
    type: 'Archers',
    level: 4,
    quantity: 10
  }
  let defenders = {
    type: 'Infantry',
    level: 2,
    quantity: 15
  }
  oneOnOneBattle([attackers], [defenders])
  console.log('result', attackers, defenders)
}
battleTests()

console.log("done")
</script>
